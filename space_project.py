# -*- coding: utf-8 -*-
"""Space Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EmSaB9CcYupXZH9fowIUItZOVjN7S014
"""

import numpy as np
import matplotlib.pyplot as plt
import mpl_toolkits.mplot3d.axes3d as p3
import matplotlib.animation as animation


# Attaching 3D axis to the figure
fig = plt.figure()
ax = p3.Axes3D(fig)





# Setting the axes properties

ax.set_xlabel('X')


ax.set_ylabel('Y')


ax.set_zlabel('Z')

ax.set_xlim(-3,3)
ax.set_ylim(-3,3)
ax.set_zlim(-3,3)
ax.set_title('3D Test')

# Creating the Animation object
#line_ani = animation.FuncAnimation(fig, update_lines, 25, fargs=(data, lines),
#                                   interval=50, blit=False)

#plt.show()

def focuspath(e,a,q,i,period, timediff, initialPos):
  """calculate the path of the comet based on inputs
  
  INPUTS: e = 
          a = semi major axis length
          i = inclination (cameron's phi)
          period = 
          timediff =  //this assumes t=0 is 30-Apr-2018 6:05
          initialPos = 3D vector describing planet's position at t=0
  OUTPUTS: a 3-D point
  
  """
  b = a*np.sqrt(1-e**2)
  c=np.sqrt(a**2-b**2)
  theta=0 #need a real theta value 
  xcoord = a*np.cos(timediff)*np.cos(theta)-b*np.sin(timediff)*np.sin(theta)-c*np.cos(theta) #c term is to adjust for the focus
  ycoord = a*np.cos(timediff)*np.sin(theta)*np.cos(i)+b*np.sin(timediff)*np.cos(theta)*np.cos(i)-c*np.sin(theta)*np.cos(i)
  zcoord = a*np.cos(timediff)*np.sin(theta)*np.sin(i)+b*np.sin(timediff)*np.cos(theta)*np.sin(i)-c*np.sin(theta)*np.sin(i)
  
  
  return xcoord, ycoord, zcoord
def path(e,a,q,i,period, timediff, initialPos):
  """calculate the path of the comet based on inputs
  
  INPUTS: e = eccentricity
          a = semi major axis length
          i = inclination (cameron's phi)
          period = 
          timediff =  //this assumes t=0 is 30-Apr-2018 6:05
          initialPos = 3D vector describing planet's position at t=0
  OUTPUTS: a 3-D point
  
  """
  b = a*np.sqrt(1-e**2)
  c=np.sqrt(a**2-b**2)
  theta=0 #need a real theta value 
  xcoord = a*np.cos(timediff)*np.cos(theta)-b*np.sin(timediff)*np.sin(theta)
  ycoord = a*np.cos(timediff)*np.sin(theta)*np.cos(i)+b*np.sin(timediff)*np.cos(theta)*np.cos(i)
  zcoord = a*np.cos(timediff)*np.sin(theta)*np.sin(i)+b*np.sin(timediff)*np.cos(theta)*np.sin(i)
  
  
  return xcoord, ycoord, zcoord

def earthpath():
  """calculate the path of earth
  
  INPUTS: 

  OUTPUTS: 

  """

import numpy as np


class Ceres:
  def __init__(self):
    self.xcoords = []
    self.ycoords=[]
    self.zcoords=[]
    self.datax= []
    self.datay=[]
    self.dataz=[]
  def getPath(self):
    return [self.xcoords, self.ycoords, self.zcoords]
  def createFrames(self):
    for index in frames:
      self.datax.append(self.xcoords[i])
      self.datay.append(self.ycoords[i])
      self.dataz.append(self.zcoords[i])
    return [self.datax, self.datay, self.dataz]

ceres = Ceres()
for t in range(1000):
    x, y, z = focuspath(0.076, 2.77, 0, 0.18483037, 0, t/10,0)
    ceres.xcoords.append(x)
    ceres.ycoords.append(y)
    ceres.zcoords.append(z)

#print(ceres.getPath())

data = ceres.getPath()
orbit1 = [ax.plot(data[0], data[1], data[2])[0]]
#line_ani = animation.FuncAnimation(fig, update_lines, 25, fargs=(data, lines),
##                                   interval=50, blit=True,)
earth = Ceres()
for t in range(1000):
    x, y, z = focuspath(0.016, 1, 0, 0, 0, t/10,0)
    earth.xcoords.append(x)
    earth.ycoords.append(y)
    earth.zcoords.append(z)
data = earth.getPath()
orbit2 = [ax.plot(data[0], data[1], data[2])[0]]

plt.show()